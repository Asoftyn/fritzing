<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="http://www.docbook.org/xml/5.0/rng/docbook.rng" type="xml"?>
<!-- This document was created with Syntext Serna Free. -->
<article version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1999/xhtml"
         xmlns:ns3="http://www.w3.org/1998/Math/MathML"
         xmlns:ns="http://docbook.org/ns/docbook">
  <info>
    <title>SVG in Fritzing</title>

    <subtitle>A Case Study</subtitle>

    <keywordset>
      <keyword>physical interaction design</keyword>

      <keyword>design tools</keyword>

      <keyword>prototyping</keyword>

      <keyword>EDA</keyword>
    </keywordset>

    <authorgroup>
      <author>
        <personname><firstname>Jonathan</firstname>
        <surname>Cohen</surname></personname>

        <email>jonathan@fritzing.org</email>

        <personblurb>
          <para>Jonathan Cohen is lead programmer on Fritzing.</para>
        </personblurb>

        <affiliation>
          <jobtitle>Programmer/Software Architect</jobtitle>

          <org>
            <orgname>Fachhochschule Potsdam</orgname>

            <orgdiv>Interaction Design Department</orgdiv>

            <address>
              <city>Potsdam</city>
              <street>Pappelallee 8-9</street>
              <postcode>14469</postcode>
              <country>Germany</country>
              <phone>+49 (0)331 580-00</phone>
              <fax>+49 (0)331 580-2999</fax>
            </address>
          </org>
        </affiliation>
      </author>

      <author>
        <personname><firstname>Mariano</firstname>
        <surname>Crowe</surname></personname>

        <email>merunga@fritzing.org</email>

        <personblurb>
          <para>Mariano Crowe is one of the developers of Fritzing</para>
        </personblurb>

        <affiliation>
          <jobtitle>Programmer/Software Architect</jobtitle>

          <org>
            <orgname>Fachhochschule Potsdam</orgname>

            <orgdiv>Interaction Design Department</orgdiv>

            <address>
              <city>Potsdam</city>
              <street>Pappelallee 8-9</street>
              <postcode>14469</postcode>
              <country>Germany</country>
              <phone>+49 (0)331 580-00</phone>
              <fax>+49 (0)331 580-2999</fax>
            </address>
          </org>
        </affiliation>
      </author>

      <author>
        <personname><firstname>Brendan</firstname>
        <surname>Howell</surname></personname>

        <email>brendan@fritzing.org</email>

        <personblurb>
          <para>Brendan Howell is one of the developers of Fritzing</para>
        </personblurb>

        <affiliation>
          <jobtitle>Engineer/Programmer/Artist</jobtitle>

          <org>
            <orgname>Fachhochschule Potsdam</orgname>

            <orgdiv>Interaction Design Department</orgdiv>

            <address>
              <city>Potsdam</city>
              <street>Pappelallee 8-9</street>
              <postcode>14469</postcode>
              <country>Germany</country>
              <phone>+49 (0)331 580-00</phone>
              <fax>+49 (0)331 580-2999</fax>
            </address>
          </org>
        </affiliation>
      </author>
    </authorgroup>

    <abstract>
      <para>Fritzing (www.fritzing.org) is an open-source Electronic Design
      Automation (EDA) tool aimed primarily at non-engineers. The approach is
      GUI-based, using the metaphor of working with a breadboard and
      electronic parts. After designing a circuit board, the user can export
      to any of several graphics formats for either “do it yourself” PCB
      etching, or to send it to a professional PCB production facility.</para>

      <para>Fritzing makes use of many of the features of SVG: fast rendering;
      scaling with no degradation; compact representation; precise real-world
      measurements; ease of conversion to other formats; xml manipulation for
      generation and modification; and familiarity to our intended user-base
      of artists, designers, and hobbyists.</para>
    </abstract>
  </info>

  <section>
    <title>Introduction to Fritzing</title>

    <para>Fritzing is an Open Source project to support designers and artists
    in taking the step from physical prototyping to actual product. We have
    created the Fritzing software in the spirit of Processing and Arduino,
    producing a tool that allows the designer / artist / researcher / hobbyist
    / freak / dilettante to document their Arduino-based prototype and to
    create Printed Circuit Board (PCB) layouts for manufacturing. The
    complementary Fritzing website helps users share, remix and discuss
    designs and experiences.</para>

    <para>Fritzing is essentially Electronic Design Automation (EDA) software
    with a low barrier to entry, suited to the needs of designers and artists.
    It uses the metaphor of the breadboard, to facilitate the transfer between
    hardware sketches and software representation. From there, it is possible
    to create a circuit footprint for turning the circuit into a PCB. The PCBs
    can be fabricated by the user, using DIY etching techniques or sent out to
    a manufacturer for professional production. Thus, the Fritzing process
    enables the designer to build a robust circuit which can be used in
    permanent installations or small-multiple batch production runs.<xref
    linkend="TEI2009" /></para>

    <para>Fritzing runs on Windows, Mac and Linux platforms. It is implemented
    in C++ using the Qt framework [ref to Qt here]. An early version of
    Fritzing was written in Java on top of GEF [ref] and other Eclipse
    frameworks. Internally, all graphics were represented as bitmaps (even
    SVGs were rendered into bitmaps internally), and the performance was very
    slow, especially when zooming into a view. In addition, zooming with
    bitmaps resulted in aliasing artifacts, and a large amount of code was
    written in order work around these limitations by using a multi-resolution
    bitmap scheme. Thus we learned the hard way that the next Fritzing
    platform should use "native" vector graphics for fast rendering and
    scaling with no degradation, and this was one of the factors that led us
    to choose Qt, which supports SVG rendering.</para>

    <para>For Fritzing, another important advantage of SVG is the ability to
    be able locate elements precisely, using measurements that translate
    accurately to real world units. Tolerances for printed circuit boards are
    quite small, and if one were to design a PCB in Fritzing with only
    approximate measurements, the circuit created could be produce short
    circuits from unintended cross-connections.</para>
  </section>

  <section>
    <title>Sketches and Parts</title>

    <para>In Fritzing, a document or <emphasis>sketch</emphasis> represents a
    circuit, which can be loosely defined as a set of
    <emphasis>parts</emphasis> linked by <emphasis>wires</emphasis>. A single
    sketch can be visualized in three different views:
    <emphasis>Breadboard</emphasis>, <emphasis>Schematic</emphasis>, and
    <emphasis>PCB</emphasis>; in each view the parts and wires are rendered
    differently. The breadboard view is a somewhat abstract, but still
    immediately recognizable model of the way many of our users work: starting
    with a breadboard and realistic-looking parts, and wiring them together in
    an iterative fashion. Schematic view hews fairly closely to a conventional
    electrical engineering schematic, and PCB view is a layered printed
    circuit board design model similar to that seen in CAD applications.
    Although a typical user might start with Breadboard view and gradually
    migrate to PCB view, we have found that different users have different
    approaches to circuit building and therefore how they use the three views.
    Fritzing is flexible enough to accommodate these various use cases.</para>

    <figure xml:id="fig1">
      <title>Three views</title>

      <mediaobject>
        <imageobject>
          <imagedata contentwidth="7in" fileref="bb_sch_pcb.png" format="PNG"
                     width="7in"></imagedata>
        </imageobject>
      </mediaobject>

      <caption>
        <para>The same sketch as shown in Breadboard view, Schematic view, and
        PCB view.</para>
      </caption>
    </figure>

    <para>The <emphasis>part</emphasis> is the main user-manipulable unit in
    Fritzing, and it is SVG-based. In the process of creating a sketch, a user
    assembles multiple parts by dragging them from a parts
    <emphasis>bin</emphasis>, and connects them with graphical wires. Each
    part includes a set of <emphasis>connectors</emphasis>. Each connector has
    a particular location on a part, it has a gender (male or female) and
    other metadata, and it has a <emphasis>terminal point</emphasis>--the
    point at which wires (or, in the case of female connectors, other parts)
    may attach. The wiring can be made more readable by chaninging colors,
    using bend points or by using autorouting tools.</para>

    <para>A single part is defined by multiple files: an xml-based metadata
    file (.fzp), which refers to multiple SVG files: one for each of the three
    views, plus one more for an icon. The metadata file also lists a part's
    connectors, and associates each of them with an <code>svgId</code>
    attribute. This attribute matches the <code>id</code> attribute of one
    element in each of the SVG files. So the metadata about each connector is
    found in the fzp file, but the shape and the location of the connector on
    the part are found in the SVG files. Similarly, a connector's terminal
    point has a <code>terminalId</code> attribute in the fzp file which
    matches the <code>id</code> attribute of one element in each of the SVG
    files. (Note: connectors and terminal points don't necessarily have to
    appear in all views).</para>

    <para>One advantage of this structure in which a metadata file points to
    SVG files is the possibility to reuse SVG files both within and across
    parts. This is especially helpful for PCB graphics
    (<emphasis>Footprints</emphasis>) as they generally conform to specific
    industry standard package geometries. This means that once a standard
    footprint SVG is defined, it can be reused by many many parts and the part
    author will only have to make slight changes to the images for the
    Breadboard and Schematic views.</para>

    <para>Parts can also have multiple <emphasis>layer</emphasis>s which are
    specific to a particular view. In any given view, a user can easily change
    which layers are visible. For example, in PCB view, a part might have
    Copper0 and Silkscreen layers, and a user might not want to see the
    Silkscreen layer when he is wrestling with the details of routing
    connections on the Copper0 layer. As with the previous id-correspondence
    schemes, a layer is identified in the metadata file using a
    <code>layerId</code> attribute, which corresponds to an element
    <code>id</code> in its associated view SVG file. One difference from the
    other schemes however, is that while connectors and terminal points tend
    to be fairly simple elements, layers can be quite complex hierarchies of
    elements. For example, all connector elements are usually found inside a
    single layer.</para>

    <figure xml:id="fig2">
      <title>Layers in a relay</title>

      <mediaobject>
        <imageobject>
          <imagedata contentwidth="" fileref="relay4.svg" format="svg"></imagedata>
        </imageobject>
      </mediaobject>

      <caption>
        <para>A composite view of a relay showing, respectively, both Copper0
        and Silkscreen layers, Copper0 only, and Silkscreen only.</para>
      </caption>
    </figure>

    <para>Qt provides SVG rendering support via the QSvgRenderer class. This
    class implements a superset of SVG 1.2 Tiny. However, it is not possible
    to selectively hide/show individual SVG elements using Qt's
    implementation. So our approach to the problem is to split a single view
    SVG file into multiple SVG files, one for each layer, at the time the part
    is loaded. To generate each SVG file, the header from the original SVG
    file is copied, and then the element identified by the layer's
    <code>id</code> attribute is extracted from the original file and pasted
    into the new layer SVG file.</para>

    <para>We considered having separate SVG files for each layer, but we
    planned for users to create their own parts using standard vector drawing
    tools like Inkscape and Illustrator <xref linkend="PARTSEDITOR" />, and we
    concluded that large collections of files would unnecessarily complicate
    the process. In addition, working with a single image file for each view
    makes it easier to preserve the spatial correspondence between layers in
    that view. We also considered keeping everything--metadata and all the
    view SVGs--in a single SVG file, but we concluded that this would make
    part creation more difficult and would complicate image reuse.</para>
  </section>

  <section>
    <title>Exporting</title>

    <para>Once a user has finished creating a sketch (i.e. laying out a
    circuit), for purposes of production or documentation, it must be
    converted to other formats. Fritzing provides a number of different export
    options, depending on the end production technology. PDF and PostScript
    outputs are provided by Qt, and once we figured out that Qt stores images
    internally at 90 dpi, we were able to ensure that parts would be printed
    at their true real-world sizes. PNG and JPEG outputs are also provided by
    Qt, so we simply had to set the right image resolution to ouput images at
    the proper size.</para>

    <para>However, exporting to SVG proved a little more complicated. Qt does
    not provide a method to take a sketch composed of separately rendered
    parts and wires, and convert that to a single SVG file, so we had to
    devise our own approach:</para>

    <itemizedlist>
      <listitem>
        The first step is to take all of the individual part SVGs and 

        <emphasis>normalize</emphasis>

         them. That is, we set up the target SVG with 

        <code>width</code>

        , 

        <code>height</code>

        , and 

        <code>viewBox</code>

         atrributes so that coordinates are expressed in 1000 dpi units. Then we go through each part, converting its coordinates and other scale-relative attribute values (

        <code>radius</code>

        , 

        <code>stroke-width</code>

        , etc) to 1000 dpi units.
      </listitem>

      <listitem>
        During this step we also translate the part coordinates to absolute coordinates within the full sketch-- this makes subsequent parsing easier. 
      </listitem>

      <listitem>
         Depending on the purpose of the export, we may change the value of an element's 

        <code>stroke</code>

         and 

        <code>fill</code>

         attributes. For example, if you are exporting a PCB for DIY etching, which needs a solid black image, we will set the 

        <code>stroke</code>

         and 

        <code>fill</code>

         attributes to 

        <code>black</code>

        .
      </listitem>

      <listitem>
        Next, we convert all the wires in the sketch to 

        <code>line</code>

         elements.
      </listitem>

      <listitem>
        Again, depending on the purpose of the export, only certain layers of a given part will be visible, so elements belonging to the non-visible layers are ignored.
      </listitem>
    </itemizedlist>

    <para>We originally picked 1/1000 inch resolution because it is the most
    common standard unit in professional PCB manufacturing. However, we found
    that many of our users import the Fritzing-exported SVGs into Adobe
    Illustrator, which converts everything internally to 72 dpi. This would
    not be a problem if Illustrator also converted the stroke-width attribute,
    but Illustrator does not, so user sketches showed up in Illustrator
    rendered dramatically incorrect. So we now export our SVGs at 72dpi as a
    workaround.</para>

    <section>
      <title>Gerber Export</title>

      <para>While exporing a printable graphic image is very useful and
      effective for home or small lab production, almost all professional PCB
      production houses expect files in the Gerber RS-274-X format. This
      format, often simply called <emphasis>Gerber</emphasis>, was created in
      the 1970s by the Gerber Systems Corp (now owned by Mania Technologie AG)
      to drive photoplotting machines. The file describes the movement of a
      photoplotter head with a series of commands: move, light-on, light-off,
      aperture size change and shape change. The action of exposing a
      photo-sensitive film to light creates a <emphasis>resist</emphasis>
      which is used to define the areas of the circuit board which will be
      etched. While most modern photoplotters are actually raster based, the
      legacy standard lives on.</para>

      <para>To export to Gerber format, we first go through the SVG export
      process (using 1000dpi), then walk through the SVG element tree, where
      there is a more-or-less one-to-one correspondence between Gerber
      elements and SVG elements. Gerber has some limitations, however. The
      only curves supported in gerber are complete circles or circular arc
      segments, so currently there are no footprints in Fritzing with bezier
      curves. While it has not yet been implemented, we have considered
      several algorithms to convert SVG curves to poly-lines or arc segments.
      In addition there is no support in Gerber for fonts or generic text. One
      possible solution is to map SVG path-based font tables to straight lines
      and circular arc segments.</para>
    </section>

    <section>
      <title>Ground Plane Generation</title>

      <para>There is one further manipulation to perform when Fritzing exports
      for etching (or to Gerber format): when part footprints and traces are
      exported, it leaves large areas of the PCB unfilled, and removing all
      the copper from these areas is time consuming; wasteful of etchant
      chemicals; and depending on the production process, less environmentally
      sound. Furthermore, some or all of these unfilled areas can be connected
      to ground, which makes routing the PCB much easier. Finally, using a
      ground plane in printed circuits can reduce signal noise.</para>

      <para>Our first idea for how to implement a ground plane was once again
      to generate a single sketch SVG but increase each element's stroke-width
      attribute by some percent, and then subtract this modified sketch shape
      from the shape of the board. However, we couldn't find an easy way to
      perform subtraction directly in SVG space. So our next idea was to
      render the fattened sketch into a bitmap, then find some way to
      vectorize that back into an SVG. It is unnecessary to work with such a
      bitmap at a high resolution: it is much more important to set the
      stroke-width on all parts and wires wide enough to avoid any short
      circuits. We looked at using the Potrace library [ref] for doing the
      vectorization, but as that seemed to be more than we needed (and because
      it was an interesting problem), we developed our own solution.</para>

      <para>The first version simply went through the bitmap line-by-line and
      generated a horizontal <code>line</code> element for each set of
      contiguous horizontal empty pixels. Our second version was a little more
      clever and used the endpoints of all those horizontal empty lines to
      create a set of filled <code>polygon</code> elements (i.e. a polygon for
      each empty "island" in the bitmap). There is still room for optimization
      by removing redundant endpoints in the polygons, but our ground plane
      implementation is working. Similar techniques could be used to create a
      more flexible solder mask layer.</para>

      <figure xml:id="fig3">
        <title>Sketch exported for etching</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="gp.svg" format="svg"></imagedata>
          </imageobject>
        </mediaobject>

        <caption>
          <para>A composite view of an an exported sketch, shown,
          respectively, without ground plane and with ground plane. We allow
          the ground plane to intersect with ground wires.</para>
        </caption>
      </figure>
    </section>
  </section>

  <section xml:id="PARTSEDITOR">
    <title>Parts Editor</title>

    <para>While we provide a set of common and useful Core parts it is quite
    impossible to maintain a library that could even begin to hold every part
    that any user could possibly want to use. Therefore, we encourage users to
    create their own parts and we provide a Parts Editor for that purpose. As
    many of our users are artists and designers, we know that they have both
    the capacity and interest needed to create the images for the different
    views. Furthermore, most of them are familiar with vector graphics tools,
    such as Illustrator or Inkscape. The parts editor allows them to integrate
    these images into a part definition, define connectors for each view, and
    add metadata for the part and each individual connector.</para>

    <figure xml:id="fig4">
      <title>Parts Editor</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="pe.png" format="svg" width="7in"></imagedata>
        </imageobject>
      </mediaobject>

      <caption>
        <para>Parts Editor Window: Specifications and Connectors</para>
      </caption>
    </figure>

    <para>In the Parts Editor, the user imports an SVG for each view, and
    allows the user to attach connectors by representing them as on-screen
    manipulable rectangles. The user can then move and resize the connectors.
    The Parts Editor ensures that the correspondence between SVG element
    <code>id</code>s and their metadata references are consistent. Since these
    SVGs can come from any source, it is often convenient to recycle images
    from existing similar parts. If an SVG already has connectors defined,
    they are represented on-screen and if the user should delete any of them,
    the connector references are removed from the SVG file as it is saved.
    While maintaining this consistency has caused a lot of hair tearing for
    the programmers, it has proved to be a popular feature with our
    users.</para>

    <section>
      <title>A tool problem</title>

      <para>As this application is intended for "non-technical" users, one of
      our goals is to avoid forcing the user to hand-edit markup files. As a
      result, we have come to be highly dependent on Inkscape and Illustrator
      and this has exposed us to a number of bugs and idiosyncracies in their
      respective SVG implementations.</para>

      <para>Illustrator's main flaws are its lack of real world measurement
      units, which are completely necessary in Fritzing and its "obsession" on
      preprocessing standard svg on load, process that doesn't use an
      homogenic approach, and tends to leave some elements and/or attributes
      un- or mis-transformed. <remark>here I would like to say that
      illustrator also somehow "indoctrinate" the users, and make them think
      that the svg format is ONLY what illustrator can do, but i'm not
      completely sure about it :)</remark></para>

      <para>Even Inkscape, opposite to illustrator, as a vector graphics tools
      which target file format IS svg, is still far from being the
      first-choice tool for designers. And it also has its technical flaws
      <remark>(... for developers i mean)</remark>, for example its extremely
      verbose inkscape svg format and how it tends to define objects
      attributes inside a huge style-attribute value, what makes the markup
      svg nature quite useless.</para>

      <para>applies transforms all over the place. adds sodipodi elements that
      collide with svg and breaks in qt. everyone seems to have their own idea
      of what svg 1.2 tiny is and what they support. no validation
      tools.</para>

      <para>inkscape and illustrator are both mostly overkill for our
      purposes</para>

      <para>We want to make our own simplified SVG editor and make it
      standards compliant and have a nice ui. but who has time!?</para>
    </section>
  </section>

  <section>
    <title>Part Generators</title>

    <para>The electronics industry has produced an astounding number and
    variation of components. Even with Open Source crowdsourcing techniques,
    mirroring this diversity by hand producing Fritzing parts is an almost
    futile task. Thanks to powerful templating tools for XML we were able to
    create a set of scripts that enable us to quickly create large sets of
    similar SVG images. We can rapidly and automatically crank out large sets
    of standard resistors, capacitors, ICs, etc. without having to slave over
    them. Templates can be created using standard SVG tools and then modified
    to spit out parts with various different combinations of colors, sizes,
    and numbers of pins.</para>

    <para>While Fritzing itself is written in pure C++, our website and many
    of our development utilities are coded in Python. We chose to use
    Cheetah's powerful templating system for our parts generators as it
    integrates nicely with Python. A typical script will iterate over a range
    or set of variables and create the unique SVGs and XML metadata files for
    each part. This process was extremely useful in the early stages of
    development when the file format was frequently changing. [cheetah
    template ref]</para>

    <para>Finally, we have integrated these scripts into our web site so that
    users can simply fill out a web form to create custom parts to their
    specification. These parts can be modified using the Parts Editor and SVG
    authoring tools, just as with parts made from scratch. Our hope is that
    given a sufficient collection of these scripts, the majority of special
    parts could be generated and only the most exotic parts would need to be
    created by hand.</para>
  </section>

  <section>
    <title>Conclusion</title>

    <para>We discussed our experiences with an early version of Fritzing in
    which images are stored internally in bitmaps, and how this led us to
    adopt a vector graphics approach to take advantage of such features as
    scaling with no degradation, and precise real-world units. We adopted a
    multi-file metadata/svg format for parts, and showed a number of ways we
    work with this format. We have talked about we manipulate SVG xml inorder
    to export to various formats. and we have implemented a parts editors with
    a workflow that involves importing svgs from other tools, manipulating
    them, and saving them in our own format. We have also discussed how our
    users move SVGs back and forth between Fritzing and Inkscape or
    Illustrator (and some ways in which these tools are lacking). The text
    based nature of the SVG has enabled us to take advantage of tools to
    automatically generate parts and collectoins of parts. We can confidently
    assert that the kinds of manipulations that we are doing currently in
    Fritzing would never have been possible in the earlier raster-based
    version, has made our application easier to develop, more compatible with
    external toolsand overall make Fritzing a much more user-friendly,
    powerful,and speedy system to use.</para>

    <para></para>
  </section>

  <bibliography>
    <biblioentry xml:id="TEI2009">
      <abbrev>TEI2009</abbrev>

      <authorgroup>
        <author>
          <personname><surname>Knörig</surname>
          <firstname>A.</firstname></personname>
        </author>

        <author>
          <personname><surname>Wettach</surname>
          <firstname>R.</firstname></personname>
        </author>

        <author>
          <personname><surname>Cohen</surname>
          <firstname>J.</firstname></personname>
        </author>
      </authorgroup>

      <title>Fritzing – A tool for advancing electronic prototyping for
      designers</title>

      <biblioset relation="conference">
        <title>In Proceedings of the 3rd International Conference on Tangible
        and Embedded Interaction</title>

        <pubdate>2009</pubdate>

        <confgroup>
          <conftitle>International Conference on Tangible and Embedded
          Interaction</conftitle>

          <confdates>February 16-18, 2009</confdates>

          <address>Cambridge, England</address>
        </confgroup>
      </biblioset>
    </biblioentry>
  </bibliography>
</article>
